
T2693.hs:11:7:
    Couldn't match expected type ‘TFn a’ with actual type ‘TFn _a’
    NB: ‘TFn’ is a type function, and may not be injective
    The type variable ‘_a’ is ambiguous
    When checking that ‘x’ has the inferred type
      x :: forall _a. TFn _a
    Probable cause: the inferred type is ambiguous
    In the expression:
      do { let Just x = ...;
           let n = fst x + fst x;
           return () }
    In an equation for ‘f’:
        f = do { let Just x = ...;
                 let n = ...;
                 return () }

T2693.hs:19:15:
    Couldn't match expected type ‘(_r, _b)’ with actual type ‘TFn _a2’
    The type variables ‘_r’, ‘_b’, ‘_a2’ are ambiguous
    Relevant bindings include n :: _r (bound at T2693.hs:19:7)
    In the first argument of ‘fst’, namely ‘x’
    In the first argument of ‘(+)’, namely ‘fst x’

T2693.hs:19:23:
    Couldn't match expected type ‘(_a3, _r)’ with actual type ‘TFn _a4’
    The type variables ‘_r’, ‘_a3’, ‘_a4’ are ambiguous
    Relevant bindings include n :: _r (bound at T2693.hs:19:7)
    In the first argument of ‘snd’, namely ‘x’
    In the second argument of ‘(+)’, namely ‘snd x’

T2693.hs:29:20:
    Couldn't match type ‘TFn _a’ with ‘PVR _a1’
    The type variables ‘_a’, ‘_a1’ are ambiguous
       Expected type: () -> Maybe (PVR _a1)
         Actual type: () -> Maybe (TFn _a)
    In the first argument of ‘mapM’, namely ‘g’
    In a stmt of a 'do' block: pvs <- mapM g undefined
