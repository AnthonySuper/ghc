
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Static semantics  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
CoreLint :: '' ::=

defn |- prog program ::  :: lintCoreBindings :: 'Prog_' {{ com Program typing, \coderef{coreSyn/CoreLint.lhs}{lintCoreBindings} }}
  {{ tex \labeledjudge{prog} [[program]] }}
by

G = </ vars_of bindingi // i />
no_duplicates </ bindingi // i />
</ G |-bind bindingi // i />
--------------------- :: CoreBindings
|-prog </ bindingi // i />

defn G |- bind binding ::  :: lint_bind :: 'Binding_' {{ com Binding typing, \coderef{coreSyn/CoreLint.lhs}{lint\_bind} }}
  {{ tex [[G]] \labeledjudge{bind} [[binding]] }}
by

G |-sbind n <- e
---------------------- :: NonRec
G |-bind n = e

</ G |-sbind ni <- ei // i />
---------------------- :: Rec
G |-bind rec </ ni = ei // i />

defn G  |- sbind n <- e ::  :: lintSingleBinding :: 'SBinding_' {{ com Single binding typing, \coderef{coreSyn/CoreLint.lhs}{lintSingleBinding} }}
  {{ tex [[G]] \labeledjudge{sbind} [[n]] [[<-]] [[e]] }}
by

G |-tm e : t
G |-name z_t ok
</ mi // i /> = fv(t)
</ mi elt G // i />
----------------- :: SingleBinding
G |-sbind z_t <- e

defn G  |- tm e : t ::  :: lintCoreExpr :: 'Tm_'
  {{ com Expression typing, \coderef{coreSyn/CoreLint.lhs}{lintCoreExpr} }}
  {{ tex [[G]] \labeledjudge{tm} [[e]] : [[t]] }}
by

x_t elt G
not (t is_a_coercion_type)
------------------ :: Var
G |-tm x_t : t

t = literalType lit
------------------- :: Lit
G |-tm lit : t

G |-tm e : s
G |-co g : s k1~#k2 t
k2 elt { *, # }
------------------- :: Cast
G |-tm e |> g : t

G |-tm e : t
------------------- :: Tick
G |-tm e {tick} : t

G' = G, alpha_k
G |-ki k ok
G' |-subst alpha_k |-> s ok
G' |-tm e[alpha_k |-> s] : t
--------------------------- :: LetTyKi
G |-tm let alpha_k = s in e : t

G |-sbind x_s <- u
G |-ty s : k
G, x_s |-tm e : t
------------------------- :: LetNonRec
G |-tm let x_s = u in e : t

</ G'i $ // i /> = inits(</ zi_si // i />)
</ G, G'i |-ty si : ki // i />
no_duplicates </ zi // i />
G' = G, </ zi_si // i />
</ G' |-sbind zi_si <- ui // i />
G' |-tm e : t
------------------------ :: LetRec
G |-tm let rec </ zi_si = ui // i /> in e : t

% lintCoreArg is incorporated in these next two rules

G |-tm e : forall alpha_k.t
G |-subst alpha_k |-> s ok
---------------- :: AppType
G |-tm e s : t[alpha_k |-> s]

G |-tm e : forall c_phi.t
G |-co g : phi
------------------------- :: AppCo
G |-tm e g : t[c_phi |-> g]

not (e2 is_a_type)
G |-tm e1 : t1 -> t2
G |-tm e2 : t1
---------------- :: AppExpr
G |-tm e1 e2 : t2

not (k is_a_coercion_type)
G |-ty t : k
G, x_t |-tm e : s
----------------- :: LamId
G |-tm \x_t.e : t -> s

G |-ki k ok
G,alpha_k |-tm e : t
--------------------------- :: LamTy
G |-tm \alpha_k.e : forall alpha_k. t

phi = s1 k1~#k2 s2
G |-ki phi ok
G,c_phi |-tm e : t
-------------------------------- :: LamCo
G |-tm \c_phi.e : forall c_phi.t

G |-tm e : s
G |-ty s : k1
G |-ty t : k2
</ G, z_s; s |-altern alti : t // i />
---------------------------------------------------- :: Case
G |-tm case e as z_s return t of </ alti // i /> : t

G |-co g : t1 k1~#k2 t2
-------------------- :: Coercion
G |-tm g : t1 k1~#k2 t2

defn G  |- name n ok ::  :: lintSingleBinding_lintBinder :: 'Name_'
  {{ com Name consistency check, \coderef{coreSyn/CoreLint.lhs}{lintSingleBinding\#lintBinder} }}
  {{ tex [[G]] \labeledjudge{n} [[n]] [[ok]] }}
by

G |-ty t : k
----------------- :: Id
G |-name x_t ok

----------------- :: TyVar
G |-name alpha_k ok

defn G |- bnd n ok ::  :: lintBinder :: 'Binding_'
  {{ com Binding consistency, \coderef{coreSyn/CoreLint.lhs}{lintBinder} }}
  {{ tex [[G]] \labeledjudge{bnd} [[n]] [[ok]] }}
by

G |-ty t : k
--------------------------------- :: Id
G |-bnd x_t ok

G |-ki k ok
---------------------------------------- :: TyVar
G |-bnd alpha_k ok

defn G  |- co g : phi ::  :: lintCoercion :: 'Co_'
  {{ com Coercion typing, \coderef{coreSyn/CoreLint.lhs}{lintCoercion} }}
  {{ tex [[G]] \labeledjudge{co} [[g]] : [[phi]] }}
by

G |-ty t : k
---------------------- :: Refl
G |-co <t> : t k~#k t

G |-co g1 : s1 k1~#k'1 t1
G |-co g2 : s2 k2~#k'2 t2
G |-arrow k1 -> k2 : k
G |-arrow k'1 -> k'2 : k'
------------------------- :: TyConAppCoFunTy
G |-co (->) g1 g2 : (s1 -> s2) k~#k' (t1 -> t2)

T /= (->)
</ G |-arg wi : (si : k'i, ti : ki) // i />
G |-app </ (si : k'i) // i /> : tyConKind T ~> k'
G |-app </ (ti : ki) // i /> : tyConKind T ~> k
--------------------------------- :: TyConAppCo
G |-co T </ wi // i /> : T </ si // i />  k'~#k T </ ti // i />

G |-co g : s1 k1~#k2 s2
G |-arg w : (t1 : k'1, t2 : k'2)
G |-app (t1 : k'1) : k1 ~> k3
G |-app (t2 : k'2) : k2 ~> k4
--------------------- :: AppCo
G |-co g w : (s1 t1) k3~#k4 (s2 t2)

G, alpha_k |-co g : t1 k1~#k2 t2
G |-ty forall alpha_k.t1 : k1
G |-ty forall alpha_k.t2 : k2
--------------------------------------------------------------------------- :: ForAllCo_TyHomo
G |-co forall alpha_k. g : (forall alpha_k. t1) k1~#k2 (forall alpha_k. t2)

G |-co h : k1 *~#* k2
G, alpha1_k1, alpha2_k2, c_(alpha1$ k1~#k2 alpha2$) |-co g : t1 k3~#k4 t2
G |-ty forall alpha1_k1.t1 : k3
G |-ty forall alpha2_k2.t2 : k4
----------------------------------------------------------------------------------------------- :: ForAllCo_TyHetero
G |-co forall h (alpha1_k1, alpha2_k2, c$). g : (forall alpha1_k1. t1) k3~#k4 (forall alpha2_k2. t2)

c # |g|
G, c_phi |-co g : t1 k1~#k2 t2
G |-ty forall c_phi.t1 : k1
G |-ty forall c_phi.t2 : k2
----------------------------------------------------------------- :: ForAllCo_CoHomo
G |-co forall c_phi. g : (forall c_phi.t1) k1~#k2 (forall c_phi.t2)

c1 # |g|
c2 # |g|
G |-co h : phi1 *~#* phi2
phi1 /= phi2
G, c1_phi1, c2_phi2 |-co g : t1 k1~#k2 t2
G |-ty forall c1_phi1.t1 : k1
G |-ty forall c2_phi2.t2 : k2
---------------------------------------------------------------------------------- :: ForAllCo_CoHetero
G |-co forall h (c1_phi1, c2_phi2). g : (forall c1_phi1.t1) k1~#k2 (forall c2_phi2.t2)

z_phi elt G
phi = t1 k1~#k2 t2
----------------------- :: CoVarCo
G |-co z_phi : phi

G |-ty t1 : k1
G |-ty t2 : k2
----------------------------- :: UnsafeCo
G |-co t1 ==>! t2 : t1 k1~#k2 t2

G |-co g : t1 k1~#k2 t2
------------------------- :: SymCo
G |-co sym g : t2 k2~#k1 t1

G |-co g1 : t1 k1~#k2 t2
G |-co g2 : t2 k2~#k3 t3
----------------------- :: TransCo
G |-co g1 ; g2 : t1 k1~#k3 t3

G |-co g : (T </ sj // j />) k1~#k1' (T </ tj // j />)
length </ sj // j /> = length </ tj // j />
i < length </ sj // j />
G |-ty si : k2
G |-ty ti : k2'
not (si is_a_coercion)
not (ti is_a_coercion)
---------------------- :: NthCoTyCon
G |-co nth i g : si k2~#k2' ti

G |-co g : (forall z1_k1.t1) k3~#k4 (forall z2_k2.t2)
--------------------------- :: NthCoForAll
G |-co nth 0 g : k1 *~#* k2

G |-co g : (s1 s2) k~#k' (t1 t2)
G |-ty s1 : k1
G |-ty t1 : k1'
----------------------- :: LRCoLeft
G |-co Left g : s1 k1~#k1' t1

G |-co g : (s1 s2) k~#k' (t1 t2)
G |-ty s2 : k2
G |-ty t2 : k2'
not (s2 is_a_coercion)
not (t2 is_a_coercion)
----------------------- :: LRCoRight
G |-co Right g : s2 k2~#k2' t2

G |-co g : (forall z1_k1.t1) k3~#k4 (forall z2_k2.t2)
G |-arg w : (s1 : k1', s2 : k2')
k1' <: k1
k2' <: k2
--------------------- :: InstCo
G |-co g w : (t1[z1_k1 |-> s1]) k3~#k4 (t2[z2_k2 |-> s2])

C = T </ axBranchkk // kk />
0 <= ind < length </ axBranchkk // kk />
forall </ ni // i />. (</ s1j // j /> ~> t1) = (</ axBranchkk // kk />)[ind]
G |-axk [ </ ni // i /> |-> </ wi // i /> ] ~> (subst1, subst2)
</ s2j = subst1(s1j) // j />
no_conflict(C, </ s2j // j />, ind-1)
t2 = subst2(t1)
s2 = T </ s2j // j />
G |-ty s2 : k
G |-ty t2 : k'
------------------------------------------------------ :: AxiomInstCo
G |-co C ind </ wi // i /> : s2 k~#k' t2

G |-co g : t1 k1~#k2 t2
G |-ty t1 |> h : k1'
---------------------------------- :: CoherenceCo
G |-co g |> h : t1 |> h k1'~#k2 t2

G |-co g : t1 k1~#k2 t2
-------------------------- :: KindCo
G |-co kind g : k1 *~#* k2

defn G |- axk [ names |-> args ] ~> ( subst1 , subst2 ) ::  :: check_ki :: 'AxiomKind_'
  {{ com Axiom argument kinding, \coderef{coreSyn/CoreLint.lhs}{check\_ki} }}
  {{ tex [[G]] \labeledjudge{axk} [ [[names]] [[|->]] [[args]] ] [[~>]] ([[subst1]], [[subst2]]) }}
by

--------------------------------------- :: Empty
G |-axk [empty |-> empty] ~> (empty, empty)

G |-axk [names |-> args] ~> (subst1, subst2)
G |-arg w : (t1 : k1, t2 : k2)
n = z_k
k1 <: subst1(k)
k2 <: subst2(k)
----------------------------- :: Arg
G |-axk [ names, n |-> args, w ] ~> (subst1 [n |-> t1], subst2 [n |-> t2])

defn G |- arg w : ( t1 : k1 , t2 : k2 ) ::  :: lintCoArg :: 'Arg_'
  {{ com Coercion argument kinding, \coderef{coreSyn/CoreLint.lhs}{lintCoArg} }}
  {{ tex [[G]] \labeledjudge{arg} [[w]] : ([[t1]] : [[k1]], [[t2]] : [[k2]]) }}
by

G |-co g : t1 k1~#k2 t2
------------------------------ :: TyCoArg
G |-arg g : (t1 : k1, t2 : k2)

% could perhaps use coercionKind here instead of lintCoercion
G |-co g1 : phi1
G |-co g2 : phi2
----------------------------------------- :: CoCoArg
G |-arg (g1, g2) : (g1 : phi1, g2 : phi2)

defn G |- ki k ok ::  :: lintKind :: 'K_'
  {{ com Kind validity, \coderef{coreSyn/CoreLint.lhs}{lintKind} }}
  {{ tex [[G]] \labeledjudge{k} [[k]] [[ok]] }}
by

G |-ty k : *
-------------- :: Star
G |-ki k ok

G |-ty k : #
-------------- :: Hash
G |-ki k ok

defn G |- ty t : k ::  :: lintType :: 'Ty_'  
  {{ com Kinding, \coderef{coreSyn/CoreLint.lhs}{lintType} }}
  {{ tex [[G]] \labeledjudge{ty} [[t]] : [[k]] }}
by

z_k elt G
------------ :: TyVarTy
G |-ty z_k : k

G |-ty t1 : k1
G |-ty t2 : k2
G |-app (t2 : k2) : k1 ~> k
--------------- :: AppTy
G |-ty t1 t2 : k

G |-ty t1 : k1
G |-ty t2 : k2
G |-arrow k1 -> k2 : k
------------------- :: FunTy
G |-ty t1 -> t2 : k

not (isUnLiftedTyCon T) \/ length </ ti // i /> = tyConArity T
</ G |-ty ti : ki // i />
G |-app </ (ti : ki) // i /> : tyConKind T ~> k
--------------------------- :: TyConApp
G |-ty T </ ti // i /> : k

G |-ki k1 ok
G, z_k1 |-ty t : k2
------------------------ :: ForAllTy
G |-ty forall z_k1. t : k2

G |-tylit lit : k
-------------- :: LitTy
G |-ty lit : k

G |-ty t : k1
G |-co g : k1 *~#* k2
--------------------- :: CastTy
G |-ty t |> g : k2

G |-co g : phi
-------------- :: CoercionTy
G |-ty g : phi

defn G |- subst n |-> t ok ::  :: lintTyKind :: 'Subst_'
  {{ com Substitution consistency, \coderef{coreSyn/CoreLint.lhs}{lintTyKind} }}
  {{ tex [[G]] \labeledjudge{subst} [[n]] [[|->]] [[t]] [[ok]] }}
by

G |-ty t : k2
k2 <: k1
---------------------- :: Type
G |-subst z_k1 |-> t ok

defn G ; s |- altern alt : t ::  :: lintCoreAlt :: 'Alt_'
  {{ com Case alternative consistency, \coderef{coreSyn/CoreLint.lhs}{lintCoreAlt} }}
  {{ tex [[G]];[[s]] \labeledjudge{alt} [[alt]] : [[t]] }}
by

G |-tm e : t
--------------------- :: DEFAULT
G; s |-altern _ -> e : t

s = literalType lit
G |-tm e : t
---------------------------------------- :: LitAlt
G; s |-altern lit -> e : t

T = dataConTyCon K
not (isNewTyCon T)
t1 = dataConRepType K
t2 = t1 {</ sj // j />}
</ G |-bnd ni ok // i />
G' = G, </ ni // i />
G' |-altbnd </ ni // i /> : t2 ~> T </ sj // j />
G' |-tm e : t
--------------------------------------- :: DataAlt
G; T </ sj // j /> |-altern K </ ni // i /> -> e : t

defn t' = t { </ si // , // i /> } ::  :: applyTys :: 'ApplyTys_'
  {{ com Telescope substitution, \coderef{types/Type.lhs}{applyTys} }}
by

--------------------- :: Empty
t = t { }

t' = t{</ si // i />}
t'' = t'[n |-> s]
-------------------------- :: Ty
t'' = (forall n. t) { s, </ si // i /> }

defn G |- altbnd vars : t1 ~> t2 ::  :: lintAltBinders :: 'AltBinders_'
  {{ com Case alternative binding consistency, \coderef{coreSyn/CoreLint.lhs}{lintAltBinders} }}
  {{ tex [[G]] \labeledjudge{altbnd} [[vars]] : [[t1]] [[~>]] [[t2]] }}
by

------------------------- :: Empty
G |-altbnd empty : t ~> t

G |-subst beta_k' |-> alpha_k ok
G |-altbnd </ ni // i /> : t[beta_k' |-> alpha_k] ~> s
------------------------------------------------------ :: TyVar
G |-altbnd alpha_k, </ ni // i /> : (forall beta_k'.t) ~> s

G |-altbnd </ ni // i /> : t[z_phi |-> c_phi] ~> s
------------------------------------------------------- :: IdCoercion
G |-altbnd c_phi, </ ni // i /> : (forall z_phi.t) ~> s

G |-altbnd </ ni // i /> : t2 ~> s
----------------------------------------------- :: IdTerm
G |-altbnd x_t1, </ ni // i /> : (t1 -> t2) ~> s

defn G |- arrow k1 -> k2 : k ::  :: lintArrow :: 'Arrow_'
  {{ com Arrow kinding, \coderef{coreSyn/CoreLint.lhs}{lintArrow} }}
  {{ tex [[G]] \labeledjudge{\rightarrow} [[k1]] [[->]] [[k2]] : [[k]] }}
by

k1 elt { *, # }
k2 elt { *, # }
------------------------- :: Kind
G |-arrow k1 -> k2 : *

defn G |- app kinded_types : k1 ~> k2 ::  :: lint_app :: 'App_'
  {{ com Type application kinding, \coderef{coreSyn/CoreLint.lhs}{lint\_app} }}
  {{ tex [[G]] \labeledjudge{app} [[kinded_types]] : [[k1]] [[~>]] [[k2]] }}
by

--------------------- :: Empty
G |-app empty : k ~> k

k <: k1
G |-app </ (ti : ki) // i /> : k2 ~> k'
---------------------------------------------------- :: FunTy
G |-app (t : k), </ (ti : ki) // i /> : (k1 -> k2) ~> k'

k <: k1
G |-app </ (ti : ki) // i /> : k2[z_k1 |-> t] ~> k'
-------------------------------------------------------- :: ForAllTy
G |-app (t : k), </ (ti : ki) // i /> : (forall z_k1. k2) ~> k'

defn k1 <: k2 ::  :: isSubKind :: 'SubKind_'
  {{ com Sub-kinding, \coderef{types/Kind.lhs}{isSubKind} }}
by

------ :: Refl
k <: k

-------------------- :: UnliftedTypeKindOpen
# <: OpenKind

------------------- :: LiftedTypeKindOpen
* <: OpenKind

defn no_conflict ( C , </ sj // j /> , ind ) ::  :: check_no_conflict :: 'NoConflict_'
  {{ com Branched axiom conflict checking, \coderef{coreSyn/CoreLint.lhs}{lintCoercion\#check\_no\_conflict} }}
by

------------------------------------------------ :: NoBranch
no_conflict(C, </ si // i/>, -1)

C = T </ axBranchkk // kk />
forall </ ni // i />. (</ tj // j /> ~> t') = (</ axBranchkk // kk />)[ind]
apart(</ sj // j />, </ tj // j />)
no_conflict(C, </ sj // j />, ind-1)
------------------------------------------------ :: Branch
no_conflict(C, </ sj // j />, ind)
